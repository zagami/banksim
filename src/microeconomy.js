// Generated by CoffeeScript 1.9.3
var Bank, CentralBank, InterbankMarket, MicroEconomy, Params, Statistics, TrxMgr, assert, randomize, randomizeInt;

assert = function(condition, message) {
  var e;
  if (!condition) {
    message = message || "Assertion failed";
    if (typeof Error !== "undefined") {
      e = new Error(message);
      console.log(e.stack);
      alert(message);
      throw e;
    }
    throw message;
  }
};

randomize = function(from, to) {
  var x;
  x = to - from;
  return parseFloat(from + x * Math.random());
};

randomizeInt = function(from, to) {
  var x;
  x = to - from + 1;
  return Math.floor(from + x * Math.random());
};

if (!Array.prototype.sum) {
  Array.prototype.sum = function() {
    var i, s;
    i = this.length;
    s = 0;
    while (i > 0) {
      s += this[--i];
    }
    return s;
  };
}

Params = (function() {
  function Params() {}

  Params.prototype.max_trx = 50;

  Params.prototype.prime_rate = 0.004;

  Params.prototype.prime_rate_giro = 0.003;

  Params.prototype.libor = 0.002;

  Params.prototype.cap_req = 0.08;

  Params.prototype.minimal_reserves = 0.05;

  Params.prototype.credit_interest = 0.03;

  Params.prototype.deposit_interest = 0.02;

  return Params;

})();

Statistics = (function() {
  function Statistics() {}

  Statistics.prototype.m0 = [];

  Statistics.prototype.m1 = [];

  Statistics.prototype.inflation_m0 = [];

  Statistics.prototype.inflation_m1 = [];

  return Statistics;

})();

CentralBank = (function() {
  function CentralBank(banks) {
    this.banks = banks;
    this.stats = new Statistics();
  }

  CentralBank.prototype.credits_total = function() {
    var bank, j, len1, ref, sum;
    sum = 0;
    ref = this.banks;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      sum += bank.debt_cb;
    }
    return sum;
  };

  CentralBank.prototype.giro_total = function() {
    var bank, giro, j, len1, ref;
    giro = 0;
    ref = this.banks;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      giro += bank.reserves;
    }
    return giro;
  };

  CentralBank.prototype.assets_total = function() {
    return this.credits_total();
  };

  CentralBank.prototype.liabilities_total = function() {
    return this.giro_total() + this.capital();
  };

  CentralBank.prototype.capital = function() {
    return this.credits_total() - this.giro_total();
  };

  CentralBank.prototype.M0 = function() {
    return this.giro_total();
  };

  CentralBank.prototype.M1 = function() {
    var bank, j, len1, ref, sum;
    sum = 0;
    ref = this.banks;
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      sum += bank.giral;
    }
    return sum;
  };

  CentralBank.prototype.M2 = function() {
    return 0;
  };

  return CentralBank;

})();

InterbankMarket = (function() {
  InterbankMarket.instance = null;

  InterbankMarket.prototype.get_instance = function() {
    if (this.instance == null) {
      this.instance = new InterbankMarket();
    }
    return this.instance;
  };

  function InterbankMarket() {
    this.interbank = new Hashtable();
  }

  InterbankMarket.prototype.reset = function() {
    return this.instance = null;
  };

  InterbankMarket.prototype.give_interbank_credit = function(from, to, amount) {
    var hash, val;
    assert(from !== to, "banks not different");
    assert(amount > 0, "credit amount must be > 0");
    assert(from.reserves >= amount, "not enough reserves for interbank credit");
    assert(this.interbank !== null, "interbank null");
    from.reserves -= amount;
    to.reserves += amount;
    if (!this.interbank.containsKey(from)) {
      hash = new Hashtable();
      hash.put(to, amount);
      this.interbank.put(from, hash);
    } else {
      if (this.interbank.get(from).containsKey(to)) {
        val = this.interbank.get(from).get(to);
        this.interbank.get(from).put(to, val + amount);
      } else {
        this.interbank.get(from).put(to, amount);
      }
    }
    if (!this.interbank.containsKey(to)) {
      hash = new Hashtable();
      hash.put(from, -amount);
      return this.interbank.put(to, hash);
    } else {
      if (this.interbank.get(to).containsKey(from)) {
        val = this.interbank.get(to).get(from);
        return this.interbank.get(to).put(from, val - amount);
      } else {
        return this.interbank.get(to).put(from, -amount);
      }
    }
  };

  InterbankMarket.prototype.get_interbank_credits = function(bank) {
    var j, len1, ref, total, v;
    total = 0;
    if (this.interbank.containsKey(bank)) {
      ref = this.interbank.get(bank).values();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        v = ref[j];
        if (v > 0) {
          total += v;
        }
      }
    }
    return total;
  };

  InterbankMarket.prototype.get_interbank_debt = function(bank) {
    var j, len1, ref, total, v;
    total = 0;
    if (this.interbank.containsKey(bank)) {
      ref = this.interbank.get(bank).values();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        v = ref[j];
        if (v < 0) {
          total += Math.abs(v);
        }
      }
    }
    return total;
  };

  InterbankMarket.prototype.settle_interbank_interests = function(libor) {
    var b, j, key, len1, ref, results, val;
    ref = this.interbank.keys();
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      b = ref[j];
      results.push((function() {
        var k, len2, ref1, results1;
        ref1 = this.interbank.get(b).keys();
        results1 = [];
        for (k = 0, len2 = ref1.length; k < len2; k++) {
          key = ref1[k];
          val = this.interbank.get(b).get(key);
          this.interbank.get(b).put(key, val * (1 + libor));
          results1.push(b.capital += val * libor);
        }
        return results1;
      }).call(this));
    }
    return results;
  };

  InterbankMarket.prototype.set_gameover = function(bank) {
    var b, bank_loss, j, len1, ref;
    if (this.interbank.containsKey(bank)) {
      ref = this.interbank.get(bank).keys();
      for (j = 0, len1 = ref.length; j < len1; j++) {
        b = ref[j];
        if (this.interbank.containsKey(b)) {
          bank_loss = this.interbank.get(b).get(bank);
          if (bank_loss > 0) {
            console.log("bank just lost " + bank_loss + " from a bankcupcy");
            b.capital -= bank_loss;
          } else if (bank_loss < 0) {
            console.log("bank just gained " + (Math.abs(bank_loss)) + " a from bankrupcy");
            b.capital += Math.abs(bank_loss);
          }
          this.interbank.get(b).remove(bank);
        }
      }
      return this.interbank.get(bank).clear();
    }
  };

  return InterbankMarket;

})();

Bank = (function() {
  Bank.prototype.gameover = false;

  Bank.prototype.interbank_market = null;

  function Bank(reserves, credits, debt_cb1, giral1, capital1) {
    this.reserves = reserves;
    this.credits = credits;
    this.debt_cb = debt_cb1;
    this.giral = giral1;
    this.capital = capital1;
    this.interbank_market = InterbankMarket.prototype.get_instance();
  }

  Bank.prototype.get_random_bank = function() {
    var c, capital, debt_cb, giral, r;
    r = randomize(0, 100);
    c = randomize(r, 300);
    debt_cb = 1.1 * r;
    giral = randomize(r, c);
    capital = r + c - giral - debt_cb;
    return new Bank(r, c, debt_cb, giral, capital);
  };

  Bank.prototype.assets_total = function() {
    return this.reserves + this.credits + this.get_interbank_credits();
  };

  Bank.prototype.liabilities_total = function() {
    return this.debt_cb + this.get_interbank_debt() + this.giral + this.capital;
  };

  Bank.prototype.get_interbank_credits = function() {
    return this.interbank_market.get_interbank_credits(this);
  };

  Bank.prototype.get_interbank_debt = function() {
    return this.interbank_market.get_interbank_debt(this);
  };

  Bank.prototype.give_interbank_credit = function(to, amount) {
    return this.interbank_market.give_interbank_credit(this, to, amount);
  };

  Bank.prototype.compute_credit_potential = function(cap_req, min_res) {
    var limit_cap, limit_mr;
    limit_cap = (this.capital - cap_req * this.liabilities_total()) / cap_req;
    limit_cap = Math.max(0, limit_cap);
    limit_mr = (this.reserves - min_res * this.giral) / min_res;
    limit_mr = Math.max(0, limit_mr);
    return Math.min(limit_cap, limit_mr);
  };

  return Bank;

})();

MicroEconomy = (function() {
  function MicroEconomy(cb, banks, params) {
    this.cb = cb;
    this.banks = banks;
    this.params = params;
  }

  return MicroEconomy;

})();

TrxMgr = (function() {
  function TrxMgr(microeconomy) {
    this.microeconomy = microeconomy;
    this.banks = this.microeconomy.banks;
    this.cb = this.microeconomy.cb;
    this.interbank_market = InterbankMarket.prototype.get_instance();
    this.params = this.microeconomy.params;
  }

  TrxMgr.prototype.one_year = function() {
    this.create_transactions();
    this.pay_customer_deposit_interests();
    this.get_customer_credit_interests();
    this.get_cb_deposit_interests();
    this.pay_cb_credit_interests();
    this.pay_interbank_interests();
    this.make_statistics();
    this.check_consistency();
    return this.check_bankrupcy();
  };

  TrxMgr.prototype.check_consistency = function() {
    var a, bank, j, l, len1, ref, results;
    a = this.cb.assets_total();
    l = this.cb.liabilities_total();
    assert(Math.round(1000 * a) - Math.round(1000 * l) === 0, "central bank balance sheet inconsistent: " + a + " != " + l + " ");
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      a = bank.assets_total();
      l = bank.liabilities_total();
      results.push(assert(Math.round(1000 * a) - Math.round(1000 * l) === 0, "bank balance sheet inconsistent: " + a + " != " + l + " "));
    }
    return results;
  };

  TrxMgr.prototype.check_bankrupcy = function() {
    var bank, j, len1, ref, results;
    if (this.cb.capital() <= -0.01) {
      alert("central bank capital cannot be negative, " + (this.cb.capital()));
    }
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      if (bank.capital < -0.01 && !bank.gameover) {
        console.log("bank capital cannot be negative " + bank.capital);
        this.set_gameover(bank);
        results.push(this.check_bankrupcy());
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  TrxMgr.prototype.create_transactions = function() {
    var amount, bank_src, bank_tgt, j, max_trx, ref, results, trx;
    max_trx = randomizeInt(1, this.params.max_trx);
    console.log("performing " + max_trx + " transactions");
    results = [];
    for (trx = j = 1, ref = max_trx; 1 <= ref ? j <= ref : j >= ref; trx = 1 <= ref ? ++j : --j) {
      bank_src = randomizeInt(0, this.banks.length - 1);
      bank_tgt = randomizeInt(0, this.banks.length - 1);
      if (bank_src !== bank_tgt && !(bank_src.gameover || bank_tgt.gameover)) {
        bank_src = this.banks[bank_src];
        bank_tgt = this.banks[bank_tgt];
        amount = randomize(0, bank_src.giral);
        results.push(this.transfer(bank_src, bank_tgt, amount));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  TrxMgr.prototype.transfer = function(from, to, amount) {
    if (from.reserves < amount) {
      if (to.reserves > amount && this.params.prime_rate > this.params.libor) {
        to.give_interbank_credit(from, amount);
      } else {
        from.debt_cb += amount;
        from.reserves += amount;
      }
    }
    from.reserves -= amount;
    from.giral -= amount;
    to.reserves += amount;
    return to.giral += amount;
  };

  TrxMgr.prototype.pay_customer_deposit_interests = function() {
    var bank, debt_bank, dr, j, len1, ref, results;
    dr = this.params.deposit_interest;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      debt_bank = dr * bank.giral;
      bank.giral += debt_bank;
      results.push(bank.capital -= debt_bank);
    }
    return results;
  };

  TrxMgr.prototype.get_customer_credit_interests = function() {
    var bank, cr, debt_cust, diff, j, len1, ref, results;
    cr = this.params.credit_interest;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      debt_cust = cr * bank.credits;
      if (bank.giral < debt_cust) {
        diff = debt_cust - bank.giral;
        bank.credits += diff;
        bank.capital += debt_cust;
        results.push(bank.giral = 0);
      } else {
        bank.giral -= debt_cust;
        results.push(bank.capital += debt_cust);
      }
    }
    return results;
  };

  TrxMgr.prototype.get_cb_deposit_interests = function() {
    var bank, interest, j, len1, pr_giro, ref, results;
    pr_giro = this.params.prime_rate_giro;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      interest = pr_giro * bank.reserves;
      bank.reserves += interest;
      results.push(bank.capital += interest);
    }
    return results;
  };

  TrxMgr.prototype.pay_cb_credit_interests = function() {
    var bank, debt, diff, j, len1, pr, ref, results;
    pr = this.params.prime_rate;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      debt = pr * bank.debt_cb;
      if (debt > bank.reserves) {
        diff = debt - bank.reserves;
        bank.capital -= debt;
        bank.reserves = 0;
        results.push(bank.debt_cb += diff);
      } else {
        bank.reserves -= debt;
        results.push(bank.capital -= debt);
      }
    }
    return results;
  };

  TrxMgr.prototype.pay_interbank_interests = function() {
    return this.interbank_market.settle_interbank_interests(this.params.libor);
  };

  TrxMgr.prototype.repay_cb_credits = function() {
    var bank, j, len1, max_payback, mr, payback, pr, prg, ref, reserve_surplus, results;
    pr = this.params.prime_rate;
    prg = this.params.prime_rate_giro;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      mr = this.compute_minimal_reserves(bank);
      if (pr > prg) {
        reserve_surplus = Math.max(bank.reserves - mr, 0);
        max_payback = Math.min(bank.debt_cb, reserve_surplus);
        payback = randomize(0, max_payback);
        bank.debt_cb -= payback;
        results.push(bank.reserves -= payback);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  TrxMgr.prototype.new_cb_credits = function() {
    var bank, c, cap_req, j, len1, max_credit, pr, prg, ref, results;
    pr = this.params.prime_rate;
    prg = this.params.prime_rate_giro;
    cap_req = this.params.cap_req;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      if (pr < prg) {
        max_credit = (bank.capital - cap_req * bank.liabilities_total()) / cap_req;
        c = randomize(0, max_credit);
        bank.debt_cb += c;
        results.push(bank.reserves += c);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  TrxMgr.prototype.repay_customer_credits = function() {
    var amount, bank, cr, dr, j, len1, max_payback, ref, results;
    dr = this.params.deposit_interest;
    cr = this.params.credit_interest;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      if (dr < cr) {
        max_payback = Math.min(bank.credits, bank.giral);
        amount = randomize(0, max_payback);
        bank.credits -= amount;
        results.push(bank.giral -= amount);
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  TrxMgr.prototype.new_customer_credits = function() {
    var amount, bank, cr, j, len1, max_credit, mr, ref, results;
    ref = this.banks;
    results = [];
    for (j = 0, len1 = ref.length; j < len1; j++) {
      bank = ref[j];
      cr = this.params.cap_req;
      mr = this.params.minimal_reserves;
      max_credit = bank.compute_credit_potential(cr, mr);
      amount = randomize(0, max_credit);
      bank.credits += amount;
      results.push(bank.giral += amount);
    }
    return results;
  };

  TrxMgr.prototype.compute_minimal_reserves = function(bank) {
    var mr;
    mr = this.params.minimal_reserves;
    return mr * (bank.giral + bank.debt_cb + bank.get_interbank_debt());
  };

  TrxMgr.prototype.settle_basel2 = function() {
    var cap_req, libor, pr;
    cap_req = this.params.cap_req;
    pr = this.params.prime_rate;
    return libor = this.params.libor;
  };

  TrxMgr.prototype.make_statistics = function() {
    var infl_m0, infl_m1, len;
    this.cb.stats.m0.push(this.cb.M0());
    this.cb.stats.m1.push(this.cb.M1());
    len = this.cb.stats.m1.length;
    if (len > 1) {
      infl_m0 = (this.cb.stats.m0[len - 1] / this.cb.stats.m0[len - 2] - 1) * 100;
      this.cb.stats.inflation_m0.push(infl_m0);
      infl_m1 = (this.cb.stats.m1[len - 1] / this.cb.stats.m1[len - 2] - 1) * 100;
      return this.cb.stats.inflation_m1.push(infl_m1);
    }
  };

  TrxMgr.prototype.set_gameover = function(bank) {
    var cb_loss;
    assert(!bank.gameover, "bank is already gameover");
    bank.gameover = true;
    cb_loss = bank.debt_cb - bank.reserves;
    if (cb_loss > 0) {
      console.log("central bank just lost " + cb_loss + " from a bankrupcy");
    } else if (cb_loss < 0) {
      console.log("central bank just won " + (-cb_loss) + " from a bankrupcy");
    }
    this.interbank_market.set_gameover(bank);
    return bank.reserves = bank.credits = bank.debt_cb = bank.giral = bank.capital = 0;
  };

  return TrxMgr;

})();
